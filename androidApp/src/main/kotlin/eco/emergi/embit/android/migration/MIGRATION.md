# Data Migration Guide

## Overview

The Embit app has been completely rewritten using Kotlin Multiplatform (KMP) with a new database architecture. This migration utility helps transfer your battery monitoring data from the old Room database to the new SQLDelight database.

## What Gets Migrated

The migration process transfers:
- **All historical battery readings** from the old `energy_usage_database`
- Timestamps of measurements
- Voltage and amperage readings
- Automatically calculates missing fields (battery percentage, charging state)

## Schema Transformation

### Old Schema (Room Database)
```kotlin
@Entity
data class EnergyUsage(
    @PrimaryKey val id: Int,
    val amperage: Long,      // in amps
    val voltage: Int,        // in volts
    val time: Long           // epoch milliseconds
)
```

### New Schema (SQLDelight Database)
```kotlin
data class BatteryReading(
    val id: Long,
    val timestamp: Instant,
    val voltageMillivolts: Int,      // converted from volts
    val amperageMicroamps: Long,     // assumed already in μA
    val temperatureCelsius: Float?,  // not available, set to null
    val batteryPercentage: Int,      // estimated from voltage
    val batteryState: BatteryState   // derived from amperage sign
)
```

## Migration Process

### Automatic Migration

The app automatically checks for old data on first launch. If found, it presents a migration screen to the user.

### Manual Migration

To manually trigger migration in your code:

```kotlin
@Inject lateinit var migrationManager: DataMigrationManager

lifecycleScope.launch {
    val result = migrationManager.migrate(context)
    when (result) {
        is MigrationResult.Success -> {
            Log.i("Migration", "Migrated ${result.recordsMigrated} records")
        }
        is MigrationResult.Failed -> {
            Log.e("Migration", "Failed: ${result.error}")
        }
        is MigrationResult.AlreadyMigrated -> {
            Log.i("Migration", "Already migrated")
        }
        is MigrationResult.NoDataToMigrate -> {
            Log.i("Migration", "No old data found")
        }
    }
}
```

### Migration State

The migration utility uses SharedPreferences to track state:
- `migration_v1_completed`: Boolean flag indicating completion
- `migration_timestamp`: When migration was performed
- `records_migrated`: Number of successfully migrated records

### Checking Migration Status

```kotlin
val isCompleted = migrationManager.isMigrationCompleted(context)
val stats = migrationManager.getMigrationStats(context)

stats?.let {
    println("Migrated ${it.recordsMigrated} records at ${it.timestamp}")
}
```

## Data Transformations

### 1. Unit Conversions

**Voltage**: Converted from volts to millivolts
```kotlin
voltageMillivolts = voltage * 1000
```

**Amperage**: Assumed to already be in microamps
```kotlin
amperageMicroamps = amperage  // no conversion needed
```

### 2. Battery Percentage Estimation

Estimated using Li-ion voltage curve (3.0V = 0%, 4.2V = 100%):
```kotlin
fun estimateBatteryPercentage(voltageVolts: Float): Int {
    return when {
        voltageVolts >= 4.2 -> 100
        voltageVolts <= 3.0 -> 0
        else -> ((voltageVolts - 3.0) / (4.2 - 3.0) * 100).toInt()
    }
}
```

### 3. Battery State Derivation

Determined from amperage sign:
```kotlin
val batteryState = when {
    amperage > 0 -> BatteryState.Charging
    amperage < 0 -> BatteryState.Discharging
    else -> BatteryState.NotCharging
}
```

### 4. Missing Data Handling

- **Temperature**: Not available in old schema, set to `null`
- **Battery ID**: Auto-generated by SQLDelight

## Error Handling

### Graceful Failures

The migration manager handles errors gracefully:
- Individual record failures don't stop the entire migration
- Warnings are collected and returned in the result
- Migration state is only marked complete if successful

### Common Issues

**1. Database Not Found**
```
Result: MigrationResult.NoDataToMigrate
Solution: No action needed - fresh install
```

**2. Record Transformation Failure**
```
Warning: "Failed to migrate record id=123: ..."
Solution: Record is skipped, migration continues
```

**3. Permission Denied**
```
Result: MigrationResult.Failed("Permission denied")
Solution: Check app permissions, try again
```

## Testing Migration

### Reset Migration State

For testing purposes, you can reset the migration state:

```kotlin
migrationManager.resetMigrationState(context)
```

⚠️ **Warning**: This only resets the migration flag, not the migrated data itself.

### Verify Migrated Data

After migration, verify data integrity:

```kotlin
val repository: IBatteryRepository = /* inject */

// Get total count
val allReadings = repository.getAllReadings().first()
println("Total readings: ${allReadings.size}")

// Check date range
val oldest = allReadings.minByOrNull { it.timestamp }
val newest = allReadings.maxByOrNull { it.timestamp }
println("Date range: ${oldest?.timestamp} to ${newest?.timestamp}")
```

## UI Integration

### Migration Screen

The `MigrationScreen` composable provides a user-friendly interface:

```kotlin
@Composable
fun MyApp(migrationManager: DataMigrationManager) {
    var showMigration by remember { mutableStateOf(true) }

    if (showMigration && !migrationManager.isMigrationCompleted(LocalContext.current)) {
        MigrationScreen(
            migrationManager = migrationManager,
            onMigrationComplete = { showMigration = false },
            onSkipMigration = { showMigration = false }
        )
    } else {
        // Main app content
        MainScreen()
    }
}
```

### Migration States

The UI handles four states:
1. **Idle**: Waiting for user to start migration
2. **InProgress**: Actively migrating data
3. **Completed**: Migration finished successfully
4. **Failed**: Error occurred, option to retry

## Performance Considerations

### Large Datasets

For apps with thousands of records:
- Migration runs on coroutine scope (non-blocking)
- Records are processed sequentially to avoid memory issues
- Each insert is a separate transaction (trade-off: slower but safer)

### Optimization Options

For better performance with large datasets, consider:

```kotlin
// Batch inserts (requires repository modification)
repository.insertReadings(batchOfReadings)

// Or use transaction wrapper
database.transaction {
    records.forEach { repository.insertReading(it) }
}
```

## Best Practices

1. **Run migration before main app initialization**
2. **Show progress UI for better user experience**
3. **Log warnings for debugging**
4. **Don't delete old database until migration confirmed**
5. **Provide option to skip migration for users**

## Rollback Strategy

If migration needs to be rolled back:

1. **Reset migration state**:
   ```kotlin
   migrationManager.resetMigrationState(context)
   ```

2. **Clear new database** (if needed):
   ```kotlin
   repository.deleteAllReadings()
   ```

3. **Re-run migration** with fixes applied

## Future Migrations

This utility is version 1. For future schema changes:

1. Create new migration classes: `DataMigrationV2`, `DataMigrationV3`
2. Track versions in SharedPreferences: `migration_v2_completed`
3. Run migrations sequentially: v1 → v2 → v3

## Support

If users experience migration issues:
1. Check logs for specific error messages
2. Verify old database file exists
3. Ensure sufficient storage space
4. Try migration reset and retry
5. As last resort, offer "skip" option with fresh start

## Related Files

- `DataMigrationManager.kt` - Core migration logic
- `MigrationScreen.kt` - UI for migration process
- `MigrationModule.kt` - Hilt dependency injection
- `SharedModule.kt` - Repository dependencies

## Technical Details

### Dependencies

The migration utility depends on:
- Old Room database classes (`EnergyUsage`, `EnergyUsageDao`)
- New SQLDelight repository (`IBatteryRepository`)
- Android Context (for database path and SharedPreferences)
- Kotlin Coroutines (for async operations)

### Thread Safety

The migration manager is:
- Thread-safe via coroutines
- Uses SharedPreferences for atomic state updates
- Singleton instance via Hilt

### Database Access

Both databases can coexist:
- Old: `/data/data/eco.emergi.embit/databases/energy_usage_database`
- New: `/data/data/eco.emergi.embit/databases/embit.db`

Migration reads from old, writes to new, doesn't delete old database.
